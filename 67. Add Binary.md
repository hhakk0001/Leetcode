# 250917

* 雙指標法:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$
* Python 內建解法(不推薦)


模擬二進位的加法，實作上需要一定技巧。

# 嘗試: 未成功

看答案前沒能完成完整程式碼。

## 對齊問題

因為加法計算式是從最右邊的位數開始計算，本來是想用補 0 的方式靠右對齊:
```python
if len(a) < len(b):
    a = '0' * (len(b) - len(a)) + a
else:
    b = '0' * (len(a) - len(b)) + b
```
或用內建函式(沒用過很難知道有這東西，或用 f-string):
```python
a = a.zfill(max(len(a), len(b)))
```

但後來發現，其實不需要真的補 0，只要用兩個指標從字串右邊向左遍歷，在運算時遇到越界直接當作是 0 即可，這種作法更靈活也更省記憶體。

## 越界問題

承上，如果用指標，就必須在迴圈內處理「越界情況」:因為兩個字串很有可能長度不一，某個指標可能會先到達 -1 或更小。
因此，對於已經越界的字串，我們可以將該位視為 0 來處理。

```python
while a_ptr >= 0 or b_ptr >= 0 or carry == 1:
    digit_a = a[a_ptr] if a_ptr >= 0 else "0"
    digit_b = b[b_ptr] if b_ptr >= 0 else "0"

    total = int(digit_a) + int(digit_b) + carry
    res.append(str(total % 2))
    carry = total // 2

    a_ptr -= 1
    b_ptr -= 1
```

另外，有一種情況需要注意的是兩個字串的指標都已經到頭(a_ptr,b_ptr < 0)，但還有最左端的進位要處理(最後一位加法結果是進位，carry = 1)。

處理作法是直接將判斷進位的變數 carry 加到迴圈的判斷式中，確保剩餘進位不被漏掉。

> 因為前面的作法是對於指標已經越界的字串，在計算該位時視為 0，所以這裡可以照常計算。


# 內建函式解題

直接使用 Python 內建的進位轉換函式。

