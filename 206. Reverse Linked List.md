# 250918

* 指標法:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$
* 遞迴法:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$(遞迴堆疊)

指標法想出來不難，但執行細節要注意。

# 第一次嘗試: 指標解 - 失敗

## 迴圈判斷式

有看出要遍歷串列並同時改變方向，但實作上不正確。

一開始習慣性地寫:
```python
while head.next:
```
但這題的重點是**反轉當前節點的指向**，如果用上面的寫法，當 head 走到最後一個節點就不會進入迴圈，導致最後一個節點的指向沒有被反轉。

所以應該是:
```python
while head:
```

## 回傳指標

承上，由於我們在每次迴圈中都會讓 head 前進，head 在執行完最後一個迴圈時，會移動到最後一個節點指向的地方，也就是 None，所以這裡應該回傳 prev。


# 指標解: 邊走訪邊反轉

其實上面講得差不多了。

1. 初始化一個指標 prev，紀錄下一位節點(反轉後的上一位節點)。
2. 當目前指向的節點 head 不為空，重複:
    1. 建立一個暫存變數 next_node，存放當前節點指向的下一位。 
    2. 將當前節點的指向反轉。
    3. 將 prev 跟 head 向下一位移動。
3. 回傳 prev。

# 遞迴法

一如既往地很玄

* Base case:
    * 空串列: 直接回傳
    * 只有一個節點: 已經走到串列尾端，回傳該節點(反轉後的串列頭部)
* Recursive Case:
    * 遞迴呼叫: 向下一個節點前進繼續反轉處理，直到找到尾端
    * 反轉: 把當前節點反轉。

在遞迴深入的過程中，到達最深層(最後一個節點)以 Base case 處理，回傳反轉後的新頭部。而在返回的過程中，每一層在回傳前會「順便」執行反轉操作。
