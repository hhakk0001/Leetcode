# 251126

DS 經典，學過二元樹就要會。

# 題目

給定一個二元樹的根節點 root，求前序走訪二元樹的節點值順序。

## 遞迴解

最常見的解法，建立一個子函式進行前序走訪，並在遞迴過程中將節點值加入要回傳的列表中。

除了記錄當前節點以外，透過遞迴函式能夠直觀地執行前序走訪(根-左-右)。

* 時間複雜度: $O(n)$
* 空間複雜度: $O(h)$，h 為樹高，主要為遞迴過程中系統產生的呼叫堆疊，視樹的平衡程度為 $O(\log n) ~ O(n)$

## 迭代解(堆疊)

遞迴靠系統呼叫堆疊（call stack）來維持狀態，所以我們也可以透過手動建立一個 stack 來執行走訪過程，具體可參考圖形的 DFS。

**注意**: 因為堆疊是後進先出，所以右子點要先於左堆疊進入堆疊。

這種寫法更容易擴充要記錄的資訊(如: 加入節點狀態、層數等)，但就不如遞迴解直觀。

* 時間複雜度: $O(n)$
* 空間複雜度: $O(h)$，h 為樹高，迭代過程中建立的堆疊，視樹的平衡程度為 $O(\log n) ~ O(n)$

# Morris Traversal(最佳，參考用)

Joseph M. MORRIS 在 1979 年的論文 「Traversing Binary Trees Simply and Cheaply」中提出的方法，能夠在不使用額外空間(系統呼叫或手動建立的堆疊)的情況下完成走訪。

其概念簡單來說，就是在訪問並記錄節點值之前，先找出它的前驅節點（inorder predecessor），並**建立一條從前驅節點的右指標連回當前節點的引線 (thread)**，使我們能拜訪完左子樹後回到上層，以便繼續走訪根節點和右子樹。


流程如下：
1. 設定當前節點 cur = root
2. 若 cur.left 為空：將當前節點加入答案序列，並訪問 cur.right。
3. 若 cur.left 不為空: 尋找左子樹中 cur 的前驅節點 pre。
   1. 若 pre.right 為空: 建立一條從 pre 到 cur 的引線。
      1. 將 pre 的右節點指標指向 cur。
      2. 將 cur 加入答案。 (前序加入根節點的位置)
      3. cur 移至 cur.left。
   2. 若 pre.right 不為空: 代表已建立引線並使用完畢。
      1. 將 pre 的右節點指標指向 None。(回復原狀)
      2. cur 移至 cur.right。

* 時間複雜度: $O(n)$
* 空間複雜度: $O(1)$

# 相關題型

# 參考資料



###### tags: `Binary Tree`, `DFS`, `Stack`