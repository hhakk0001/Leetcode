# 251023

* 排序字串做 Key 的雜湊表
    * 時間複雜度: $O(n * L log L)$, `L` 為字串平均長度。
    * 空間複雜度: $O(n * L)$
* 計數陣列(元組)做 Key 的雜湊表
    * 時間複雜度: $O(n * L)$
    * 空間複雜度: $O(n * L)$

之前有解出 242. Valid Anagram 會比較好想出來。

## 第一次嘗試: TLE

參考 242. 的解法可以知道，想知道兩個字串是否為 Anagram，最直觀的方法是將字串進行排序並比對，所以一開始的想法是:
* 建立一個二維陣列 `anagrams` 作為輸出。
* 對每個字串 s：
    * 檢查 `anagrams` 中現有的每個 `group` 的任一字串(這裡用 `group[0]`)，用排序法檢查 `s` 是否屬於該 `group` 的易位字。
    * 如果 `s` 不屬於任意一組，就新開一組 [s]。 

但這種寫法有兩個問題，從而導致執行超時:
1. 線性掃描不同組別在最壞情況下會接近 $O(N)$
2. 用排序法比對是對數時間 $O(L log L)$，而每次都要重複計算。

考慮到每個字串都會試過($O(N)$)，最後時間複雜度會變成可怕的 $O(N^2 LlogL)$。

然後 anagrams 這個變數取得不太好。

## 排序過的字串做為 Key 的雜湊表

我們將每個字串的排序結果作為它的代表形（canonical form），以此作為雜湊表中的 Key ，屬於該代表形的字串所構成的列表即是對應的 Value ，就能在 $O(1)$ 的時間內為字串分組。

排序字串的時間複雜度為 $O(L log L)$，因為要處理 N 個字串，所以總共花費 $O(N · L log L)$，需要的空間為 $O(N · L)$


## 計數陣列(元組)作為 Key 的雜湊表

同樣參考 242.，已知字串只會出現小寫英文字母(26種)，那麼也可以選擇用固定大小的陣列紀錄使用的字母數量，以此來比較字串是否互為重組詞。

以這個紀錄字母出現頻率的陣列作為字典的 Key，用來替具有相同字母分布的字串分組，不過要注意的是**字典的鍵必須是不可變且可雜湊的物件，需將陣列轉換成可雜湊的 tuple 形式**。

由於字母表的大小是固定的（26 個小寫字母），對每個字串計算頻率陣列只需 $O(L)$ 的時間，比起排序法的 $O(L \log L)$ 更高效。

## 相關題型

* 檢查易位字的方法: [242. Valid Anagram](../201%20~%20400/242.%20Valid%20Anagram.md)

## 參考資料

* [官方文件: 術語表 - hashable](https://docs.python.org/zh-tw/3.10/glossary.html)

###### tags: `Array`, `Hash Table`, `String`, `Sorting`