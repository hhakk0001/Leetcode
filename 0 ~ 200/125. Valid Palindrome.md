# 250915

* 雙指標法(最佳):
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$
* 暴力法:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$

少數我覺得暴力法不太直觀的題，懂雙指標的話不難。

# 初次嘗試的修正

使用雙指標，從字串的兩端開始向中間兩兩檢查字元是否回文。

## 檢查字串的方法

題目的要求是只檢查輸入的英數字元，這裡可以直接用 `.isalnum()` 代替 `.isalpha()` 跟 `.isdigit()` 兩個函式。

### 延伸: 用正規表達式檢查字串

如果題目要求不能用內建的函式完成檢查動作，可以用正規表達式:
```python
s_new = s.sub('[^a-zA-Z0-9]', '', s).lower()
```

## 用 join 取代 += 串接

字串在 Python 中屬於不可變物件，使用 +、+= 連接字串時，實際上是新建立一個字串物件，在需要串接大量字串的情境下效率較差。

原本的程式碼:
```python
for char in s:
        if char.isalpha() or char.isdigit():
            s_new += char
```
改成:
```python
clean_chars = []
for char in s:
    if char.isalnum():  # 更簡潔的寫法（等同 isalpha() or isdigit()）
        clean_chars.append(char.lower())

s_new = ''.join(clean_chars)
```
還可以用 List Comprehension:
```python
clean_chars = [char.lower() for char in s if char.isalnum()]
left, right = 0, len(clean_chars) - 1
```

## 第二次修正

第一次修正後的空間複雜度還是 O(n)，可以考慮直接再原始字串上用雙指標檢查，檢查到的字元再進行英數字元的篩檢，就不需要額外空間存放處理過後的字串:
```python
def isPalindrome(self, s: str) -> bool:
    left, right = 0, len(s) - 1

    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left += 1
        right -= 1

    return True
```



## 暴力法

將字串的英數字元篩檢出來後，直接用切片反轉字串