# 251007

* 遞迴法: Top-down
    * 時間複雜度: $O(n^2)$
    * 空間複雜度: $O(n)$(遞迴堆疊)
* 遞迴法: Bottom-up
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$(遞迴堆疊)

可以先解過 104. Maximum Depth of Binary Tree，再來看這題比較好寫

## 第一次嘗試: 遞迴(由上至下)

這題首先要解決的問題是如何得到左、右子樹的高度，可以參考 104. 的解法，使用遞迴的方式累加左、右子樹的高度，這裡以 `get_height` 函式進行計算。

解題的思路大致為:
1. 檢查根節點是否為 0。
2. 計算左、右子樹高度，並檢查高度差是否在 1 之內。
    1. 若否則回傳 False
3. 確認所有節點都是平衡的


### 修正: 檢查所有節點
第一次在解的時候犯了個錯誤是只檢查了根節點的平衡情況:
```python
if abs(left_height - right_height) <= 1:
    return True
else:
    return False
```
應該這樣寫:
```python
if abs(left_height - right_height) > 1:
    return False

return self.isBalanced(root.left) and self.isBalanced(root.right)
```
同樣以遞迴的方式檢查根以下的節點，只要有一個節點不滿足則回傳 False。

這麼做的問題也很明顯，單純走訪完整棵樹的時間是 $O(n)$。而對每個節點，我們都重新計算一次其左、右子樹的高度，如果是平均情況下，高度為 h 的樹需要花費 $O(h) = O(logn)$ 的時間，則總花費時間是 $O(nlogn)$; 最差的情況則是 $O(n^2)$。

## 遞迴法:由下至上

前述的方法是從根節點開始遞迴，會需要重複計算不同節點的子樹高度。
我們可以換個角度想，無論從哪個節點開始，計算高度最終都需要到達葉節點，因此，我們可以改為**從下而上**的方式，在返回累計高度的同時檢查各個節點的高度差。

---

在前面的程式中，`get_height` 函式遞迴至檢查到葉節點後，會從 0 開始向上回傳高度，每回傳一層時，高度就順勢加 1:

```python
# 已經遇到葉節點，高度為 0
if not node:
    return 0

# ...呼叫遞迴檢查左右子樹...

return max(left_height, right_height) + 1
```

在遞迴返回根節點的過程中，經過的每個節點就會知道自己左右子樹的高度。如果有任意節點的高度差大於 1，就回傳 -1 表示「二元樹已經確定不平衡」。

```python
# 檢查左子樹
left_height = self.check(node.left)
if left_height == -1:
    return -1  # 若左子樹不平衡，直接返回

# 檢查右子樹
right_height = self.check(node.right)
if right_height == -1:
    return -1  # 若右子樹不平衡，直接返回

# 若高度差大於 1，也是不平衡
if abs(left_height - right_height) > 1:
    return -1
```



# 參考

* 計算樹高: [104. Maximum Depth of Binary Tree]()


###### tags: `Binary Tree`, `DFS`
