# Sliding Window 滑動視窗

滑動視窗（Sliding Window）是一種用於有效地處理「連續子集合」問題的技巧。

常見的應用情境:
* 找出子陣列 / 子字串
  * 最大 / 最小值
  * 符合特定條件的最大 / 最小陣列

可以視為雙指標 (Two Pointers) 的一種變體。

## 基本概念

重點: **只在必要時更新資料**

假設我們要在陣列中找出一個固定大小的子集合之最大值，如果每次都得重新計算，會產生額外的計算成本並降低效率。

滑動視窗的技巧是，在視窗每次向右移動時，我們只需「更新新增的元素和移除的元素」，這樣可以避免重複計算，從而顯著提高效率。

## 常見形式

1. **固定大小的滑動視窗**：
    - 視窗大小是固定的，適合處理「找出長度為 `k` 的子陣列的最大或最小值」等問題。
    - 例如，在長度為 `n` 的陣列中，我們找出每個長度為 `k` 的連續子陣列的總和的最大值。
2. **可變大小的滑動視窗**：
    - 視窗大小是變動的，適合處理「找出符合某些條件的最短子陣列」等問題。
    - 例如，在一個陣列中找到最小長度的子陣列，使其總和大於或等於某個值。

## 範例1: 求子陣列總和最大值

假設我們有一個陣列 `nums = [1, 3, 2, 6, -1, 4, 1, 8, 2]`，目標是找出每個長度為 `k = 3` 的子陣列的總和的最大值。

### 傳統方法: Brute Force

1. 取出所有長度為 3 的子陣列，並逐個計算總和。
2. 假設陣列長度為 `n`，則需要計算約 `n - k + 1` 個子陣列的總和。
3. 每次計算總和需要遍歷 `k` 個元素，時間複雜度為 $O(n * k)$。

### 使用滑動視窗的方法

滑動視窗方法可以避免重複計算，減少計算量：

1. 首先計算第一個視窗的總和，即 `sum(nums[0:k])`，假設總和為 `current_sum`。
2. 接下來，讓視窗向右滑動，移動一次只更新一次：從 `current_sum` 中減去視窗左端的元素，並加入視窗右端的新元素。
    - 例如，當視窗從 `[1, 3, 2]` 移到 `[3, 2, 6]` 時：
        - `current_sum = current_sum - nums[0] + nums[3]`。
3. 更新 `current_sum` 後，檢查是否是最大值。
4. 重複這個過程直到處理完所有的子陣列。

這樣，每次移動視窗都只需做「一次減法和一次加法」，時間複雜度降低到 $O(n)$，大大提高了效率。

## 參考

- [Sliding Window 是甚麼?與 Two Pointer 的關係?](https://medium.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98%E7%B3%BB%E5%88%97-two-pointer-%E8%88%87sliding-window-8742f45f3f55)