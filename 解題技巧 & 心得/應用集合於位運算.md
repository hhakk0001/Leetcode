# 應用集合於位運算

在學時我們通常會學習集合論（set theory）的觀念，例如整數集合 $S=\{0, 2, 3\}$。  
而在程式中，一般以雜湊表（hash table）表示集合。
* Java：`HashSet`
* C++：`std::unordered_set`

在集合論中，我們常用到交集、聯集、包含關係等操作。如果在程式裡想要計算「兩個集合的交集」，一般做法是逐一遍歷集合元素。  
然而，有沒有更高效的方法呢？

## 以二進位表示集合

集合可以用二進位來表示，方式如下:
* **將集合內元素由小到大、由右到左映射到一個二進位字串**，其中
  * 若第 i 位為 1 : 表示元素 i 在集合中。
  * 若第 i 位為 0 : 表示不在集合中。

> 例如： 集合 $S = \{0, 2, 3\}$ 對應二進位 ${1101}_2$，可反推。

更正式地說，一個只包含非負整數的集合 $S$，可以用以下方式「壓縮」成一個整數：
$$
f(S) = \sum_{i \in S}{2^i}
$$
如集合 $S$ 就是 $2^0 + 2^2 + 2^3 = 13$，其二進位 ${1101}_2$ 就是集合的表示。

## 應用

由於以位元表示的集合中，每一個 bit 代表集合中的一個元素，  
所以對集合的二進位形式做位元運算（如 &, |, ^），就等於同時對集合中所有元素做運算。
透過這種平行運算的特性，我們可以加速以下不同情況的應用操作。

### 集合與集合

以下 & 表示按位 AND，| 表示按位 OR，^ 表示按位 XOR，~ 表示按位 NOT。

「對稱差」代表一個元素屬於其中一個集合，但不屬於另一個集合。
「差」則代表在集合 A 中、但不在集合 B 中的元素。

| 術語             | 集合                             | 位元運算                         | 集合範例                                  | 位元運算範例                                  |
| ---------------- | -------------------------------- | -------------------------------- | ----------------------------------------- | --------------------------------------------- |
| 交集             | $A \cap B$                       | $a \& b$                         | $\{0,2,3\} \cap \{0,1,2\} = \{0,2\}$      | `1101`<br>`& 0111`<br>`= 0101`                |
| 聯集（並集）     | $A \cup B$                       | $a \mid b$                       | $\{0,2,3\} \cup \{0,1,2\} = \{0,1,2,3\}$  | `1101`<br>`\| 0111`<br>`= 1111`               |
| 對稱差（互斥或） | $A \triangle B$                  | $a \oplus b$ <br> (a ^ b)        | $\{0,2,3\} \triangle \{0,1,2\} = \{1,3\}$ | `1101`<br>`⊕ 0111`<br>`= 1010`                |
| 差集             | $A \setminus B$                  | $a \& \sim b$                    | $\{0,2,3\} \setminus \{1,2\} = \{0,3\}$   | `1101`<br>`& 1001`<br>`= 1001`                |
| 差集（子集情況） | $A \setminus B,\; B \subseteq A$ | $a \oplus b$ <br> (a ^ b)        | $\{0,2,3\} \setminus \{0,2\} = \{3\}$     | `1101`<br>`⊕ 0101`<br>`= 1000`                |
| 包含關係         | $A \subseteq B$                  | $a \& b = a$ <br> $a \mid b = b$ | $\{0,2\} \subseteq \{0,2,3\}$             | `0101 & 1101 = 0101`<br>`0101 \| 1101 = 1101` |

注意: 
* 包含關係的兩種寫法等價，亦可用 `(a & ~b) == 0` 判斷，若成立則表示 A 也為 B 子集。
* 撰寫程式時，需注意運算符優先級。

### 集合與元素

通常會用到位元運算子 `>>`、`<<`。

| 術語                     | 集合                           | 位元運算                   | 集合範例                                             | 位元運算範例                   |
| ------------------------ | ------------------------------ | -------------------------- | ---------------------------------------------------- | ------------------------------ |
| 空集                     | $\varnothing$                  | $0$                        |                                                      |                                |
| 單元素集合               | $\{i\}$                        | $1 \ll i$                  | $\{2\}$                                              | $1 \ll 2$                      |
| 全集                     | $U = \{0,1,2,\ldots,n-1\}$     | $(1 \ll n) - 1$            | $\{0,1,2,3\}$                                        | $(1 \ll 4) - 1$                |
| 補集                     | $U \setminus S$                | $((1 \ll n) - 1) \oplus s$ | $U=\{0,1,2,3\}$ <br> $U \setminus \{1,2\} = \{0,3\}$ | `1111`<br>`⊕ 0110`<br>`= 1001` |
| 屬於                     | $i \in S$                      | $(s \gg i) \& 1 = 1$       | $2 \in \{0,2,3\}$                                    | `(1101 >> 2) & 1 = 1`          |
| 不屬於                   | $i \notin S$                   | $(s \gg i) \& 1 = 0$       | $1 \notin \{0,2,3\}$                                 | `(1101 >> 1) & 1 = 0`          |
| 添加元素                 | $S \cup \{i\}$                 | $s \mid (1 \ll i)$         | $\{0,3\} \cup \{2\}$                                 | `1001 \| (1 << 2)`             |
| 刪除元素                 | $S \setminus \{i\}$            | $s \& \sim (1 \ll i)$      | $\{0,2,3\} \setminus \{2\}$                          | `1101 & ~ (1 << 2)`            |
| 刪除元素（一定在集合中） | $S \setminus \{i\},\, i \in S$ | $s \oplus (1 \ll i)$       | $\{0,2,3\} \setminus \{2\}$                          | `1101 ⊕ (1 << 2)`              |
| 刪除最小元素             |                                | $s \& (s - 1)$             |                                                      | 見下                           |

```python
      s = 101100
    s-1 = 101011 // 最低位的 1 變 0，同時 1 右邊的 0 都取反變成 1。
s&(s-1) = 101000 
```

注意: **當 s 為 2 的次方數 (冪數)，`s & (s-1) == 0`。**


---

另外，程式語言中也多有提供與二進位有關的函式:
* 計算**二進位中的 1 之個數** => **集合大小**。
* 計算**二進位的長度** => **`長度 - 1` 等於集合的最大元素**。
* 計算**二進位尾端 0 之個數** => **集合的最小元素**。
這些函式的時間複雜度皆為 $O(1)$。

| 術語         | Python                        | Java                                            | C++                                 | Go                      |
| ------------ | ----------------------------- | ----------------------------------------------- | ----------------------------------- | ----------------------- |
| 集合大小     | `s.bit_count()`               | `Integer.bitCount(s)`                           | `__builtin_popcount(s)`             | `bits.OnesCount(s)`     |
| 二進位長度   | `s.bit_length()`              | `$32 - \text{Integer.numberOfLeadingZeros}(s)$` | `$ \lfloor \log_2(s) \rfloor + 1 $` | `bits.Len(s)`           |
| 集合最大元素 | `s.bit_length() - 1`          | `$31 - \text{Integer.numberOfLeadingZeros}(s)$` | `$ \lfloor \log_2(s) \rfloor $`     | `bits.Len(s) - 1`       |
| 集合最小元素 | `((s & -s).bit_length() - 1)` | `Integer.numberOfTrailingZeros(s)`              | `__builtin_ctz(s)`                  | `bits.TrailingZeros(s)` |

注意: **`s & -s` 會得到 lowbit（最低位的 1）**。

### 走訪集合

假設集合的元素範圍是從 0 到 n-1，要判斷元素 i 是否屬於集合 s（用位元表示），  
可以前一節提到的屬於關係，透過右移與 AND 運算：

```python
for i in range(n):
    if (s >> i) & 1:  # i 在 s 中
        # ...
```

也可以直接依序取出集合中的最小元素並刪除，直到集合為空。

```python
t = s
while t:
    lowbit = t & -t
    t ^= lowbit # 移除最低位元代表的元素
    i = lowbit.bit_length() - 1 # 取得元素編號
    # ...
```

### 列舉集合

#### 列舉所有集合

假設元素範圍是 0 到 n-1，要列舉所有非空集合 s，只要讓 s 從 1 數到 < 2^n 即可。
```python
for s in range(1 << n):
    # 處理集合 s 的邏輯
    pass
```

#### 列舉非空子集合

若已知某集合 `s`，要**從大到小列舉其所有非空子集合 `sub`**。
正常的暴力解法是從 `s` 開始不斷減一 (`sub -= 1`)，  
但該作法會產生許多非 `s` 子集合的數。

舉個例子: `s = 10101` 的最低位元的 1 在第 0、2、4 位。
如果依序減一，得到的結果會是如下
* `sub = 10101 - 1 = 10100`，是 s 的合法子集。
* `sub = 10100 - 1 = 10011`，第 1 位與 s 不同，不是 s 的合法子集。
* `sub = 10011 - 1 = 10010`，第 1 位與 s 不同，不是 s 的合法子集。
* `sub = 10010 - 1 = 10001`，是 s 的合法子集。
* ...

若要讓每次減完之後都保留在集合 `s` 的範圍內，可以執行 `sub = (sub - 1) & s`。
如此一來，會更動的部分就只有原本在 `s` 中為 1 的位數，  
而原本為 0 的位數就不會變成 1，確保 `sub` 為 `s` 的子集。

```py
sub = s
while sub:
    # 處理 sub 的邏輯

    sub = (sub - 1) & s
```

#### 列舉子集合(包含空集)

python:
```python
sub = s
while True:
    # 處理 sub 的邏輯

    if sub == 0:
        break

    sub = (sub - 1) & s
```
Java、C++:
```java
int sub = s;
do {
    // 處理 sub 的邏輯
    sub = (sub - 1) & s;
} while (sub != s);
```

由於電腦系統多使用二補數來表示負數，當 `sub = 0` 時再減 1 就會變成 -1，  
若繼續執行迴圈，`sub` 就會變回 `s`。   
因為在二進位中 `-1 = 111...1`，使得 `(sub - 1) & s = s`。  
這也意味著當 `sub = 0` (即空集合)，代表所有可能的集合都已經試過一遍，可以結束迴圈了。

#### 列舉超集

若集合 T 是集合 S 的子集合（$T \subseteq S$），則 S 稱為 T 的超集合（superset）。

用 OR 操作保證 T 包含的元素 S 都包含。

```python
s = t

while s < (1 << n):
    # 處理 s 的邏輯

    s = (s + 1) | t
```