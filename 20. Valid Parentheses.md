# 250914

* 暴力法: 超時
    * 時間複雜度: $O(n^2)$
    * 空間複雜度: $O(1)$ 
* 堆疊:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$

能想到用堆疊就很簡單

## 堆疊法

括號的使用特性在於:
* 括號必成對出現，且先左後右
* 最晚開的括號必須最早關上

堆疊的後進先出的特性可以用於檢察右括號是否和最接近的左括號成對，我們將字串逐一檢查放入的括號:
* 左括號: 直接放入堆疊
* 右括號: 檢查堆疊頂部是否有對應的左括號:
    * 有代表括號配對成功，彈出頂端左括號，並繼續檢查括號。
    * 無代表括號不成對，無效。

如果括號成對的，就會被彈出堆疊，我們只需在程式的最後檢查堆疊是否為空，就能知道字串中的括號組合是否有效。


### 細修

第一次嘗試寫:
```python
    for b in s:
        if b == "}" and stack[-1] == "{":
            stack.pop()
        elif b == "]" and stack[-1] == "[": 
            stack.pop()
        elif b == ")" and stack[-1] == "(":
            stack.pop()
        else:
            stack.append(b)
```
但遇到stack為空會跳出 `IndexError: list index out of range`，可改成:
```python
    for b in s:
        # 先檢查堆疊
        if not stack:
            stack.append(b)
        elif b == "}" and stack[-1] == "{":
            stack.pop()
```
甚至可以這樣寫:
```python
    mapping = {
            "}": "{",
            "]": "[",
            ")": "("
    }

    for char in s:
        if char in mapping.values():  # 如果是左括號
            stack.append(char)
        elif char in mapping: # 如果右括號
            # 如果堆疊為空，或者最近的括號不是對應的左括號，代表無效
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
        
    # 簡化 if/else 檢查 stack 是否為空的敘述
    return not stack
```

先建立一個左右括號的對照表，就可以不用硬寫多個 if/elif，而是用 python 的 dict 查表函式處理。
