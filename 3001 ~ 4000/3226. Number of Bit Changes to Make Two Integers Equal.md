# 251204

需要對位元運算有一定理解，不難但要想一下。

# 題目

給定兩正整數 `n`、`k`，現在可以在二進位表示中選擇任意位數，將 `n` 的二進位中的 1 位元轉換為 0。  
回傳將 `n` 轉換成 `k` 所需要更動的位元數; 若無法更動則回傳 -1。

## 暴力解

同時將 `n`、`k` 之二進位一位一位向右移，每次檢查兩數之最低位，若符合題目要求就將計數加 1。

檢查最低位的方法是將右移後的 `n` 或 `k` 與 1 進行 AND 運算。

* 時間複雜度: $O(\log n)$
* 空間複雜度: $O(1)$

## 位元運算

把問題簡化成兩個小問題:
1. n 是否能透過 1 => 0 的操作變成 k?
2. 若 1. 為是，需要改動幾個位元?

第一個問題等同是在問 **k 是否為 n 的子集**，可以透過以下方法確認:
* 檢查兩者的交集是否為 k: `(n & k) == k`。
* 檢查兩者的聯集是否為 n: `(n | k) == n`。
* 檢查 k 與 n 的差集是否為空: `(k & ~n) == 0`。

第二個問題則是確認 **n 跟 k 不同的位數**，可以透過 XOR 操作得知，即 `n ^ k` 中為 1 之個數。  
在 Python 中可用 `bit_count()` 計算。


* 時間複雜度: $O(1)$
* 空間複雜度: $O(1)$

# 相關題型

# 參考資料

* [哞靠靠 - LeetCode 3226.](https://mocowcow.github.io/leetcode-3226-number-of-bit-changes-to-make-two-integers-equal/)

###### tags: `Bit Manipulation`
