# 251028


* 模擬
    * 時間複雜度: $O(n^2)$
    * 空間複雜度: $O(1)$
* 前綴和: 最佳
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$



# 題意解析

題目要求看起來相對複雜，但若將執行過程圖像化會更容易理解。
可以參考[官方討論區的動畫示意（無程式碼）](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/comments/3214358/)。
整個過程就像一個簡化版的「打磚塊」小遊戲，不同的是這顆「球」在一維陣列上移動。

遊戲規則（行為模擬）
* 球（指標）**必須從某個值為 0 的位置** 開始。
* 並選擇一個方向（左或右）開始移動。
* 在移動過程中：
    * 若當前位置的值為 0 → 直接照原方向前進。
    * 若遇到非 0 (碰到牆)→ 將該**值減 1，並反轉方向繼續移動**。
    * 若球移出陣列範圍 → 結束。

> 題目要求：找出「所有可能的起點與方向組合」，使得在遊戲結束時，整個陣列的元素值都恰好變為 0。

## 第一次嘗試

由於球在陣列內左右來回「反彈」、每次接觸非零元素都會將其遞減，
若最終能讓整個陣列歸零，表示：
* 所有的減法操作「剛好」被平均分配到陣列的兩側。
* 當球從某個 0 開始時，只要在它移出邊界前完成所有「扣除任務」，陣列就能全歸零。

有兩種情境滿足以上條件:
* 若**初始位置左邊的元素總和 = 右邊的總和**，納無論向左或右出發，球都能平衡兩側操作，使最終全為 0 => 從該位子出發有 **2 種走法**。
* 若**兩側總和相差正好為 1**，球應該往總和較大的一側出發，這樣在移動過程中可多執行一次「減 1」操作，最終仍能讓整體歸零 => 從該位子出發有 **1 種走法**。

### 修正: 前、後綴和

計算球所在索引的左、右總和時，可以進一步優化為前綴和的寫法，減少重覆計算。

```python
    # 計算陣列內每個索引的前綴和(不含當前索引)
    prefix = [0]
    for x in nums:
        prefix.append(prefix[-1] + x)

    total = prefix[-1]
    valid_count = 0

    for i, x in enumerate(nums):
        if x == 0:
            # 直接使用已經計算好的前綴和
            left_sum = prefix[i]
            right_sum = total - prefix[i+1]
            if left_sum == right_sum:
                valid_count += 2
            elif abs(left_sum - right_sum) == 1:
                valid_count += 1

    return valid_count
```

除了額外建立陣列外，因為這題需要走訪陣列來判斷可能的走法，我們可以直接邊走邊計算當前索引的前綴和:

```python
    # 計算好總和，並在走訪陣列時同步更新前綴和
    total_sum = sum(nums)
    left_sum = 0
    valid_count = 0

    for n in nums:
        if n == 0:
            right_sum = total_sum - left_sum
            if left_sum == right_sum:
                valid_count += 2
            elif abs(left_sum - right_sum) == 1:
                valid_count += 1
        left_sum += n  # 更新前綴和

    return valid_count
```

# 相關題型



# 參考資料

* [打磚塊遊戲的起源: Breakout](https://zh.wikipedia.org/zh-tw/%E6%89%93%E7%A3%9A%E5%A1%8A)

###### tags: `Array`, `Prefix Sum`, `Simulation`