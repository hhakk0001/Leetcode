# 251221

每日一題，接續 944.，
不難但題目有點複雜，最佳解需要想一下。

# 題目

給一個字串陣列 `strs`，包含 `n` 個等長字串。  
可選擇任意數量的刪除索引，使得陣列中所有字串的該索引元素被刪除。

> 如: `strs = ["abcdef","uvwxyz"]`，`deletion indices = {0, 2, 3}`  
> 得到 `["bef", "vyz"]`。

求至少要刪除多少欄，才能使字串依照字典序非遞減排列。

## 分析

這題與 I 不同的地方在於，不強制要求每一直欄由上到下符合字典序。

## 第一次嘗試: 貪心

我們可以根據貪心法的概念來模擬刪去欄位的過程，逐步建構符合題目要求的陣列。

建立一個長度為 n 的新陣列:
* 判斷固定直欄內相鄰橫列的字母是否皆符合字典序:
  * 若是，則將該直欄的字母加入陣列，代表保留原陣列的該欄位。
  * 若否，則跳過並檢查下一個欄位。
* 計算新陣列與原陣列的字串長度差，即為所求。


* 時間複雜度: $O(n * m^2)$，比較字串大小需要 O(n * m) 次，且每次最多需要比較長度為 O(m) 的字串。
* 空間複雜度: $O(n * m)$ 

## 貪心優化

在這題的情境中，可能會出現以下情況:

>  `strs=["ac", "ad", "ba", "bb"]`，展開來看是:  
> ac  
> ad  
> ba  
> bb

可以看出第一直欄符合字典序，是不需要刪除的。  
需要注意的是，因為 `strs[1][0] < strs[2][0]`，且該欄位會保留，  
代表不論這兩個字串的後幾位字母是甚麼，  
最後得到的新陣列 `res_strs` 都會是 `res_strs[1] < res_strs[2]`。

也就是說，先前已經比較過、確定符合字典序的相鄰字串就不需再比較了。  
可以用雜湊表或是布林值陣列來紀錄是否需要比較某對相鄰字串。

* 時間複雜度: $O(n * m)$
* 空間複雜度: $O(n)$

# 相關題型

* [944. Delete Columns to Make Sorted](944.%20Delete%20Columns%20to%20Make%20Sorted.md): 雙迴圈比較字串字元
* [27.](): 參考如何實作刪除無需比較的索引之方法

# 參考資料

###### tags: `Array`, `String`, `Greedy`