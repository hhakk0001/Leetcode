# 250910

* 雜湊表: 直觀的解法
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$
* 排序取中位數: 需要想一下
    * 時間複雜度: $O(n log n)$
    * 空間複雜度: $O(1) ~ O(n)$，取決於使用的排序方法
* 摩爾投票法: 偏背
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$


## 雜湊表法: 細修

題目的要求是`the element that appears more than ⌊n / 2⌋ times`

第一次嘗試的寫法是:
```python
# 找到出現次數過半的數字
        for n, times in nums_dict.items():
            if times >= (len(nums) / 2):
                return n
```
應寫成
```python
# 找到出現次數過半的數字
        for n, times in nums_dict.items():
            if times > len(nums) // 2:
                return n
```
更符合題意

### 歷遍並計算次數的其他寫法

```python
# 如果數字出現過就增加次數
    for n in nums:
        if n in nums_dict:
            nums_dict[n] += 1
        else:
            nums_dict[n] = 1
```
可換成
```python
    for n in nums:
        nums_dict[n] = nums_dict.get(n, 0) + 1
```
或是使用 python 的標準函式庫 `collections` 中的 `defaultdict`
```python
from collections import defaultdict
    nums_dict = defaultdict(int)

    for n in nums:
        nums_dict[n] += 1
```

但個人感覺沒第一種寫法那麼直觀

## 排序取中位數法

因為題目表明 `You may assume that the majority element always exists in the array.`，代表陣列中必定存在這個過半的主要元素。

我們可以對陣列作排序，因為主要元素過半，所以不論主要元素的頭尾在哪，其範圍必然會涵蓋中位數，找到中位數並將其回傳即可。


## 摩爾投票法

適用情況: 在一組元素序列中尋找占半數以上、且只有一個的主要元素。

1. 初始化一個候選元素 candidate 跟其出現次數 count。
2. 走訪序列:
	1. 檢查 count 是否為 0，若是則將 candidate 設定為當前元素。
	2. 檢查當前元素是否等於 candidate，是就將 count + 1，否則 -1。
3. 回傳 candidate。

這種方式不用去一一計算所有元素的數量，只要記錄當下最多的元素跟數量即可，因為我們將不同元素當作是可抵銷的，在題目已知一定有一個元素過半數的情況下，最後一定會剩下一個計數為正的元素。