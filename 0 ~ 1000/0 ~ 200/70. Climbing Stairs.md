# 251003


* 遞迴: 超時
    * 時間複雜度: $O(2^n)$
    * 空間複雜度: $O(n)$，遞迴堆疊 
* DP:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(n)$
* 空間最佳化:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$


## 第一次嘗試

這題的關鍵在於看出從第一階開始，走到每一階的方法恰好為費氏數列。

### 遞迴法: 超時

```python
def climbStairs(self, n: int) -> int:
    if n > 2:
        return self.climbStairs(n-1) + self.climbStairs(n-2)
    else:
        return n
```

但這樣時間函數為:
$$T(n) = T(n-1) + T(n-2) + O(1)$$

如果從遞迴樹最頂層往下看([可見參考資料1.內的圖片](#參考資料))，費氏數列的遞迴函式每呼叫自身一次，下一層需要的呼叫次數就會變成接近 2 倍。如此一來，時間複雜度將變成可怕的 $O(2^n)$，實際提交也發生了超時。

### 迭代法 + DP (製表):

以陣列紀錄先前到達先前層數的方法數量，做線性的累計即可得到答案。

## 遞迴法 + 記憶化搜尋:

將紀錄爬階方法數的陣列作為參數傳入遞迴函式本身，在進行判斷並呼叫自身前，先查看陣列是否已有該階層的方法數，若有則不必再次遞迴。

## 空間最佳化: 滾動變數

不用額外空間紀錄，用兩個指標紀錄前兩階的走法數量，一路累加到第 n 階。

# 參考資料

1. [費氏數列與遞迴的時間複雜度分析](https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97%E8%AA%8D%E8%AD%98%E4%BD%95%E8%AC%82%E9%81%9E%E8%BF%B4-dea15d2808a3)