# 251022

* 雙堆疊:
    * 時間複雜度: $O(1)$
    * 空間複雜度: $O(n)$
* 單堆疊元組:
    * 時間複雜度: $O(1)$
    * 空間複雜度: $O(n)$
* 差值法: 最佳
    * 時間複雜度: $O(1)$
    * 空間複雜度: $O(1)$(相對於堆疊而言)

需要一點堆疊觀念。

## 第一次嘗試

題目要求是實現一個 MinStack，但並沒有提及有甚麼特點，只是在 Stack 的基礎上，額外要求實現一個時間複雜度須為 O(1) 的求最小值函式 `getMin(self)`。

第一次我實作了一個正常的 Stack，並嘗試用列表內建 `min()` 完成 `getMin(self)`。令人意外的是能過，但內建函式花費的時間應該不是常數，題目感覺要的也不是這個，只是測資給太鬆了。

## 雙堆疊解

用空間換時間，以額外的資料結構進行輔助。

使用另一個堆疊 `min_stack` 紀錄當前的最小值，操作為在一般 Stack 的基礎之上加入以下動作:
* `push`: 當 `min_stack 為空` 或 `輸入值 val >= min_stack 的頂端元素`，則把該元素壓入 min_stack。
* `pop`: 若彈出的值等於 min_stack 頂端元素 (即現在的最小值)，則同樣將其彈出。
* `top`: 與一般 Stack 相同。
* `getMin`: 直接回傳 `min_stack` 的頂端元素。

## 單堆疊 + 額外變數

在堆疊中，每個元素同時儲存兩個資訊：
* val：當前元素值
* curr_min：在該元素被推入時的當前最小值。

因此，每個元素都可以表示為一個 tuple (val, curr_min)。

由於 Stack **後進先出**的特性，當我們**執行 pop() 時**，堆疊會直接**回到推入該元素之前的狀態(即這個值被推入之前的狀態)**。因此，堆疊當前的最小值永遠是頂端元素的 curr_min 值，不需額外同步或重新計算。

## 差值法

只記錄「新值與當前最小值之間的差值」，而不是直接存最小值本身。

這種作法完全不需要除 Stack 以外的額外空間輔助，但較不直觀。



# 參考資料

* https://ithelp.ithome.com.tw/articles/10338083

# 相關題型

* [232. Implement Queue using Stacks](../201%20~%20400/232.%20Implement%20Queue%20using%20Stacks.md)
* [239. Sliding Window Maximum]()
* [716. Max Stack]()


