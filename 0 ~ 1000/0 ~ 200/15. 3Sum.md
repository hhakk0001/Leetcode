# 251216

雙指標之基本題型，可以先做過 [167. ](167.%20Two%20Sum%20II%20-%20Input%20Array%20Is%20Sorted.md) 比較好理解。

# 題目

給定一個整數陣列 `nums`，找出所有不重複的三元組 `[a, b, c]`，使得 `a + b + c == 0` 。

注: 三元組的**順序不重要**。

## 雙指標

題目說三個元素的順序不重要，不妨設定 i < j < k 以方便求解跟查找。

由於我們想找的三元組之和為固定值 0，  
可以一一列舉 `nums[i]` 並找 `nums[j] + nums[k] == -nums[i]` 的情況，
做法可以參考 Two Sum II 中的做法，先排序陣列再用雙指標找兩數之和。

需要注意的是，題目還要求三元組不得重複，  
因此在遍歷元素的過程中，若遇到連續兩元素相同的情況則要跳過。

### 優化

有兩個情況可以提前處理以提升效能:
* `nums[i] + nums[i + 1] + nums[i + 2] > 0`: 當前的最小三元組總和仍大於 0，因為陣列已排序，代表之後的三元組總和只會變大，皆不符合條件，可直接結束外部迴圈。
* `nums[i] + nums[-2] + nums[-1] < 0`: 當前列舉的 `nums[i]` 之最大三元組總和仍小於 0，因為陣列已排序，代表包含 `nums[i]` 的其他三元組只會更小，除非 `nums[i]` 變大，因此跳過當次外部迴圈。

* 時間複雜度: $O(n^2)$，外層迴圈列舉 `i`，內層迴圈找 `j`, `k`。
* 空間複雜度: $O(1)$

### 檢查重複的另一種寫法

跳過相同數字的部分也可以這樣寫:
```py
if j == i + 1 or nums[j] != nums[j - 1]:
    ans.append([x, nums[j], nums[k]])
```

# 相關題型

# 參考資料

###### tags: `Array`, `Two Pointers`, `Sorting`