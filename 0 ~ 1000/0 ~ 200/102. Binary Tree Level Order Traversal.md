# 251110

會 BFS 不難，重點在計算每一層節點數量。

# 題目

給一顆二元樹的根節點，回傳以層序走訪的節點值。
需要注意的是，這題的輸出格式要求為將樹中的同一層放在同一個列表裡。

## 第一次嘗試: BFS


從圖論可以知道，層序走訪就是一種 BFS，其常見模板如下:

```python
queue = deque([root])
while queue:
    node = queue.popleft()
    # process current node
    for neighbor in get_neighbors(node):
        queue.append(neighbor)
```

在二元樹中，鄰近的頂點就是左右兩個子節點(如果有的話)。
每一次 while loop 都會拜訪一個節點，並將其左右子點加入佇列。
但我們現在還要將同一層的節點歸類在一起，因此我們必須要逐層紀錄節點值。

```python
res = [] # 紀錄解答
while queue:
    # 紀錄該層的節點值
    cur_level_nodes = []

    # 計算該層的節點數量
    num_of_nodes = len(queue)

    # 用迴圈將該層節點一次拜訪完，並將下一層的節點加入佇列
    for _ in range(num_of_nodes):
        cur_node = queue.popleft()
        cur_level_nodes.append(cur_node.val)

        if cur_node.left is not None:
            queue.append(cur_node.left)
        if cur_node.right is not None:
            queue.append(cur_node.right)

    # 把該層節點值加入要回傳的結果
    res.append(cur_level_nodes)
```

* 時間複雜度: $O(n)$
* 空間複雜度: $O(n)$

### 為什麼每層節點數恰好是佇列大小

從根節點開始遍歷，BFS 會使用 queue（佇列）來維護待訪問的節點。一開始，queue 裡只有 root 節點，因此 `len(queue) = 1`，表示第一層有一個節點。

當處理完 root 並將其左右子節點加入 queue 後，queue 中變為 [left, right]，剛好就是第二層的所有節點，因此 `len(queue) = 2`。

接著處理這一層（兩個節點），每處理一個節點就會將它的子節點加入 queue。這樣在每一輪 while 迴圈開始時，queue 的大小 len(queue) 就精確對應到這一層的節點數量。

因為:
* 每一層處理的節點都來自上一層加入 queue 的節點。
* 新加入的節點會在下一輪才被處理，彼此不會混在一起。
* 因此，每一層的節點數，就等於該輪 while 迴圈開始時 queue 的大小。


# 相關題型

* [107. Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)

# 參考資料

* [BFS 經典入門題: Binary Tree Level Order Traversal](https://vocus.cc/article/65084075fd89780001276ba7)

###### tags: `Binary Tree`, `BFS`