# 251002

* 貪心法: 模擬
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(52)$，大小寫英文字元
* 貪心法: 最佳
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(52)$，大小寫英文字元
* 貪心法: 雜湊集合
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(52)$，大小寫英文字元

能看出奇偶規律，會雜湊就不難。
小心不要看到迴文就偏到 DP 或是 Stack。

## 第一次嘗試

從回文特性跟範例可以想到，最長回文的長度跟字母出現的次數的**奇偶**有關:

* 偶數可以對稱分布，使全部字母都能納入回文字串
* 而在奇數的情況下，只有兩種擺放方式:
    * 將所有字母都加入字串，放在回文字串的中心以確保對稱。
    * 去掉一個字母，讓字母數量變成偶數。

因為前者的情況只會有一次，所以在計算回文字串的長度時，可以先將奇數次字母的出現次數減 1 (轉成偶數) 並加到總長度中; 最後再補上加 1，表示將其中一個奇數字母放在回文中心。

需要注意的是，可能會出現沒有奇數次字母的情況，這時是不用加 1 的，因此我們另外設定一個 bool 參數 `is_odd` 來檢查是否有奇數次字母。

### 程式碼修改、簡化

1. 本來 `if val >= 3` 想分開判斷若是奇數次，是否為放在中心的字母，後來發現不需要，即便 val = 1,  val - 1 = 0，不論放在中間的是不是該字母，後面都會加回來。
2. `is_odd` 改 `has_odd` 更好。
3. 奇偶數次字串加總回文長度的邏輯可以合併 (不直觀，保留看法)。

## 官方解法 2: Greedy Way (Optimized)

先前的做法透過逐個判斷字母出現的奇偶，決定該字母有多少可以加入回文字串。而另一種做法則是在建立雜湊表，使用一個變數 `oddFreqCharsCount` 紀錄目前為止有多少字母出現了奇數次，並在最後減去多餘的不成對字母。

因為只有一個出現奇數次的字母能被放在回文字串的中心，其餘的奇數次字母都需要減少一次才能成對，回文字串的長度就會是:
```python
if odd_freq_chars_count > 0: # 如果有字母出現奇數次
    return len(s) - odd_freq_chars_count + 1
else:
    return len(s)
```

## 官方解法 3: Greedy Way (Hash Set)

因為字母只要是偶數就能成對並納入回文字串，可以建立一個集合紀錄出現過的字母，並執行以下操作:
* 如果字母不存在於集合中，就加入集合
* 如果存在，就從集合中把該字母剃除，並將總長度 + 2

當迴圈結束，集合中會留下的就是出現奇數次的字母，當集合不為空，就將總長度 + 1 (回文中心)。


