# 251027

* 堆積: 最佳
    * 時間複雜度:
        * `__init__()`: $O(n)$
        * `add()`: $O(\log k)$, k 為題目的第 k 個大的值
    * 空間複雜度: $O(k)$
* 排序
    * 時間複雜度:
        * `__init__()`: $O(1)$
        * `add()`: $O(m * n \log n)$, m = n - k 
    * 空間複雜度: 取決於排序方法

看到求 Top-k 問題就要想到用 Heap，注意程式實作邏輯。

## 第一次嘗試: 堆積

Top-k 問題是指求一組數值中最大的前 k 個元素，最經典的作法是使用最小堆積：
* 堆積頂部永遠是目前堆積中的最小值。
* 插入（heappush）與彈出（heappop）都是 $O(\log k)$。

> 程式碼部分使用 heapq 模組，包含 heapify、heappush 跟 heappop 等方法。

具體作法如下:
* 初始化：把初始 nums 先 heapify 成最小堆積，再縮減成 k 個：
`while len(heap) > k: heappop()`。
* 每次 `add(val)`：
    * 若堆未滿 k：直接推入；
    * 否則若 val > 堆頂：推入 val 再彈出堆頂；
    * 否則忽略。
* 此時堆頂即為當前資料流的第 k 大。

## 排序法

除了線性走訪 n 次 nums 以外，另一種方法是對 nums 做排序後，並傳回最後 k 個元素。但這樣每次 `add()` 時都必須重新進行一次排序，耗時較長。

# 相關題型

* 215. Kth Largest Element in an Array
* 1825. Finding MK Average
* 2102. Sequentially Ordinal Rank Tracker

# 參考資料

###### tags: `Heap (Priority Queue)`