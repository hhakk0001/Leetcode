# 251112

Binary Search 的經典題型，也是最標準的形式。

# 題目

給定一個遞增排序的整數陣列 nums 和一個整數 target，請撰寫一個函式來尋找 target 是否存在於陣列中：
* 若存在，回傳其索引。
* 若不存在，回傳 -1。

演算法的運行時間必須在 O(\log n) 以內。

## 第一次嘗試: 迭代法

二分搜尋的步驟如下:
1. 利用**兩指標`left` 與 `right`** ，**指向**當前搜尋區間的**起點與終點**。
2. 當右指標未越過左指標時(`left <= right`，代表區間內還有元素)，重複執行:
	1. 計算區間的中間元素索引 `mid = (left + right) // 2`。
	2. 並將元素值 `nums[mid]` 與目標值 `target` 進行比較:
		* 若 `nums[mid] < target`，代表目標值可能在**右半區間** => 將 `left = mid + 1`。
		* 若 `nums[mid] > target`，代表目標值可能在**左半區間** => 將 `right = mid - 1`。
		* 若 `nums[mid] == target`，代表**找到目標**元素，**回傳其索引 `mid`**。
3. 當右指標越過左指標 `left > right`，代表目標不在序列中，終止程式。

* 時間複雜度: $O(\log n)$
* 空間複雜度: $O(1)$

## 遞迴法

也可以寫成遞迴形式。

* 時間複雜度: $O(\log n)$
* 空間複雜度: $O(\log n)$，為呼叫堆疊的深度


# 相關題型

* [2529. Maximum Count of Positive Integer and Negative Integer]()


# 參考資料

###### tags: `Array`, `Binary Search`