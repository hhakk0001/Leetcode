# 250928

* 雜湊表: 
    * 時間複雜度: $O(n)$
        * s 的長度 `m` + t 的長度 `n` => $O(m+n)$
    * 空間複雜度: $O(1)$
        * 小寫字母共 26 種可能，所以最多為 $O(26)$
* 陣列計數:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$
* 排序法: 視排序方法而定
    * 時間複雜度: $O(n log n)$
    * 空間複雜度: $O(1) \ or \ O(n)$



## 第一次嘗試: 雜湊表解

這一題乍看跟 383. Ransom Note 很類似，所以先嘗試用相同的解法去做，後來發現題目要求有些許不同。

這題我們想要確認 `t` 是否是 `s` 的 anagram（字母重組詞），這代表 `t` 必須要用到 `s` 的所有字母，而 Ransom Note 是不需要使用 magazine 中的所有字的。

最簡單的做法就是直接在最後檢查字典 `letters` 減去 `t` 中使用的次數後是否等於 0，即所有在 `s` 中得到的字母都在 `t` 中剛好被用完。

```python
for k, v in letters.items():
    if v != 0:
        return False

return True
```

但實際上可以不用這麼麻煩，因為第二個 loop 在檢查 `t` 的時候，就會把字母不夠用的情況排除，因此就只需要關注字母是否用完。這點可以透過檢查兩字串長度是否相等來做到，我們可以在程式開頭加上:

```python
if len(s) != len(t):  # 長度不同，直接返回 False
    return False
```

如果字母都恰好用完，`s` 跟 `t` 的長度應該是相等的，多餘或不足的情況依照題意就直接返回 False。


## 陣列計數法

既然題目規定字串只會出現小寫英文字母(26種)，這裡也可以選擇用固定大小的陣列紀錄使用的字母數量。

不過這種方法僅限於在字母範圍已知且有限的情況下使用，泛用程度不如前面的雜湊表解


## 排序法

蠻神奇的方法，因為在 `s` 中得到的字母都在 `t` 中剛好被用完，可以直接對兩字串進行排序並比對。

很直觀，但複雜度倚賴排序的方法。

# 相關題型

* [49. Group Anagrams]()

###### tags: `Hash Table`, `String`
