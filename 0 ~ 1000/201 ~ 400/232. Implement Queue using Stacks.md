# 250914

* 暴力法: 
    * pop() 的時間複雜度: $O(n)$
* 修改-均攤時間 O(1)



## 第一次嘗試

題目規定用兩個堆疊實作，這裡先把資料裝在第一個堆疊 stack1 裡，當 queue 需要 pop 時，我們需要彈出的是前端的元素，對於 stack1 裡就是底部的元素，但題目限制只能使用 stack 的操作，而 stack 的 pop 只能從頂部(後端)操作。

這時可以把 stack1 的元素全部 pop 到另一個堆疊 stack2。因為 stack 是 LIFO，stack2 的元素順序會與在 stack1 時相反，這樣 stack2 的頂部就是原本 stack1 的底部。

## 修改

差別主要在執行 pop 跟 peek 的時候，stack2 其實不需要再把元素倒回 stack1，我們可以設定為:
* input_stack: 接收所有**後來 push 的新資料（還沒進佇列前端**
* output_stack: 保存了**排在佇列最前面的舊資料（已經進入佇列前端**

資料搬移的時機 => **當 output_stack 為空時，才會把 input_stack 整批搬過去**。

---


因為 push 只會往 input_stack 加入元素，而進入 output_stack 的元素不會再回到 input_stack，這樣的方式能確保 push 跟 pop 都符合 queue 的邏輯。

雖然直觀上不太像常見的、連貫的 queue，但概念上是一樣的。

### 攤還時間複雜度分析（Amortized Analysis）

