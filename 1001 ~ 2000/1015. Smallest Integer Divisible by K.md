# 251126


# 題目

給定一個正整數 K，找出最小的正整數 n，使 n 的每個位數只包含數字 1，且這個數能夠被 k 整除，並回傳 n 的位數。如果 n 不存在，回傳 -1。

簡單來說，n 的形式為：1, 11, 111, 1111, …，這種數被稱為**純元數 (Repunit)**。

**注意**: n 之值可能會很大，甚至超過 `long` (64-bit signed integer)

## 第一次嘗試: 找規律

檢查 n 除以 k 的規律可以發現，除了 k = 1, 2, 3, 5,...等這種能夠直接判斷是否能整除 n 的除數以外，當 n 以每次增加一個位數 1 的形式增長時，n 除以 k 的餘數會符合一種規律，例如:

> 當 k = 6:
> 1 / 6 = 0...1
> 11 / 6 = 1...5
> 111 / 6 = 18...3
> 1111 / 6 = 185...1
> 11111 / 6 = 1851...5
> ...

從上述例子可以看到，在 n 增長到四位數之後，其被除以 k 的餘數開始出現重複。
因此我們可以知道，如果在一次循環結束前，k 無法整除 n (未出現餘數為 0 的情況)，
可直接斷定 k 無法整除 n。

* 時間複雜度: $O(k)$，不計轉換 n 為字串與計算極大數的前提下。
* 空間複雜度: $O(k)$

### 修正

如果直接追蹤紀錄持續變大的 n，對於時間和空間成本是一大負擔，
不只 n 可能會溢位(視語言而定)，在將數值轉成字串時也會報錯:

除了前面提到的規律，透過同餘運算(Modular arithmetic)可知:
* $(a + b) \mod m=((a \mod m) + (b \mod m)) \mod m$
* $(a * b) \mod m=((a \mod m) * (b \mod m)) \mod m$

完全可以不必直接計算 n 實際有多大，而是只追蹤並維護餘數。

另外，基於鴿籠原理，只需最多 k 次就能知道 k 是否能整除純元數。


* 時間複雜度: $O(k)$
* 空間複雜度: $O(1)$

# 相關題型

# 參考資料

* https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj
* https://algo.monster/liteproblems/1015


###### tags: `Hash Table`, `Math`