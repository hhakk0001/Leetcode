# 251001

* 模擬法:
    * 時間複雜度: $O(n)$
    * 空間複雜度: $O(1)$
* 最佳化模擬:
    * 時間複雜度: $O(log_{M}N)$
        * `M`為 `numExchange`
    * 空間複雜度: $O(1)$
* 數學解: 皆為 O(1)

模擬法不難但需要多嘗試，數學解有一定難度。

## 第一次嘗試: 模擬法

試圖模擬真實情況，嘗試把重複做兩件事:
1. 喝掉所有水瓶
2. 把能換的空瓶換成水瓶

實務上是沒問題的，但反覆試錯了幾次才寫出正確的邏輯並通過，參數需要簡化。

* 時間複雜度: $O(n / numExchange)$ => $O(log_{M}N)$
* 空間複雜度: $O(1)$

## 官方解 1: 模擬

每次迴圈只喝並交換最低額度的瓶子數量，即 `numExchange`。

## 官方解 2: 最佳化模擬

基本上就是第一次想嘗試的做法，每次都喝掉並兌換最大限度的水瓶。

## 數學解

用空瓶兌換水瓶時，需要拿出 `numExchange` 個空瓶換取 1 個水瓶；而把這瓶水喝掉後，又會產生 1 個空瓶。也就是說，每兌換一次的空瓶淨消耗是 `numExchange - 1`。

一開始我們會把所有水瓶都喝掉，等同於有 `numBottles` 罐空瓶。因此，能夠兌換空瓶的次數就是:
```python
(numBottles - 1) // (numExchange - 1)
```
這裡要注意的是，不能直接用 `numBottles` 而要減一，因為實際上 `numBottles` 必須要大於 `numExchange` 才能進行兌換。在某些情況下的最後一次兌換，可能會出現問題:
> * 若 `numBottles` = 15, `numExchange` = 4。
>   * 實際上能夠兌換 4 次，可以喝 19 瓶。
>   * 如果用 `numBottles // (numExchange - 1)`，兌換次數會變成 15 // 3 = 5 次
>   * 但實際上，必須要 4 空瓶才能兌換 1 水瓶，而最後一次有效兌換後只會剩下三空瓶，是沒辦法兌換第五次的。

另外，該作法的前提是題意已知 `numExchange >= 2`，否則會出現分母為零的情況。